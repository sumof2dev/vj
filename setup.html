<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>DMX Setup & Fixture Editor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            --bg: #0f0f13;
            --panel: #1b1b22;
            --header: #25252e;
            --border: #333;
            --accent: #7c4dff;
            --accent-hover: #9e75ff;
            --text: #eee;
            --text-dim: #888;
            --danger: #ff4757;
            --success: #2ed573;
        }

        * {
            box-sizing: border-box;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            font-size: 14px;
        }

        /* --- LAYOUT --- */
        #nav-panel {
            width: 60px;
            background: #111;
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 20px;
            gap: 20px;
        }

        .nav-btn {
            width: 44px;
            height: 44px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.05);
            background: rgba(255, 255, 255, 0.03);
            color: #666;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 20px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .nav-btn:hover {
            color: white;
            background: #333;
        }

        .nav-btn.active {
            background: var(--accent);
            color: white;
            box-shadow: 0 0 20px rgba(124, 77, 255, 0.4);
        }

        .nav-label {
            display: none;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 4px;
            opacity: 0.6;
        }

        .nav-btn.active .nav-label {
            opacity: 1;
        }

        #main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .view-panel {
            display: none;
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            flex-direction: column;
        }

        .view-panel.active {
            display: flex;
        }

        /* --- COMPONENTS --- */
        h1,
        h2,
        h3 {
            margin: 0;
            font-weight: 500;
        }

        h2 {
            border-bottom: 1px solid var(--border);
            padding-bottom: 10px;
            margin-bottom: 20px;
            color: var(--accent);
        }

        .card {
            background: var(--panel);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .btn {
            background: #333;
            color: white;
            border: 1px solid var(--border);
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.1s;
        }

        .btn:hover {
            background: #444;
        }

        .btn.primary {
            background: var(--accent);
            border-color: var(--accent);
        }

        .btn.primary:hover {
            background: var(--accent-hover);
        }

        .btn.danger {
            background: rgba(255, 71, 87, 0.1);
            border-color: var(--danger);
            color: var(--danger);
        }

        .btn.danger:hover {
            background: var(--danger);
            color: white;
        }

        input,
        select,
        textarea {
            background: #111;
            border: 1px solid var(--border);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            width: 100%;
        }

        input:focus,
        select:focus {
            border-color: var(--accent);
            outline: none;
        }

        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 10px;
        }

        .col {
            flex: 1;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: var(--text-dim);
            font-size: 12px;
        }

        /* --- STAGE MANAGER --- */
        .device-row {
            display: grid;
            grid-template-columns: 70px 1fr 80px 60px 60px 80px 50px 100px 40px;
            gap: 10px;
            align-items: center;
            background: #222;
            padding: 10px;
            border-radius: 6px;
            margin-bottom: 8px;
            border: 1px solid transparent;
        }

        .device-row:hover {
            border-color: #444;
        }

        /* --- FIXTURE EDITOR --- */
        .json-tree {
            font-family: monospace;
            background: #111;
            padding: 10px;
            border-radius: 4px;
        }

        .mode-block {
            border-left: 2px solid var(--accent);
            padding-left: 10px;
            margin-bottom: 15px;
            background: rgba(124, 77, 255, 0.05);
            padding: 10px;
            border-radius: 0 4px 4px 0;
        }

        /* --- LIVE TEST / LOOPER --- */
        .looper-topbar {
            background: #1a1a24;
            border: 1px solid #000;
            border-bottom: 1px solid #333;
            border-top: 1px solid #333;
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            align-items: center;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .switch-track {
            width: 60px;
            height: 30px;
            background: #111;
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.8), 0 1px 1px rgba(255, 255, 255, 0.1);
            border: 1px solid #000;
            transition: background 0.3s;
        }

        .switch-track.on {
            background: rgba(46, 213, 115, 0.2);
        }

        .switch-knob {
            width: 24px;
            height: 24px;
            background: radial-gradient(circle at 30% 30%, #a4a4b5, #555 70%);
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            transition: left 0.3s;
            box-shadow: 2px 2px 5px rgba(0, 0, 0, 0.5);
            border: 1px solid #333;
        }

        .switch-track.on .switch-knob {
            left: 32px;
        }

        .switch-label {
            font-size: 14px;
            font-weight: bold;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .switch-label.on-text {
            color: var(--success);
        }

        .switch-label.off-text {
            color: var(--danger);
        }

        .led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #333;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.8);
            margin: 0 auto 5px auto;
            transition: all 0.1s;
        }

        .led.red {
            background: #ff4757;
            box-shadow: 0 0 8px #ff4757, inset 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        .led.green {
            background: #2ed573;
            box-shadow: 0 0 8px #2ed573, inset 0 1px 2px rgba(255, 255, 255, 0.5);
        }

        .scenes-panel {
            background: #1e1e28;
            border-bottom: 2px solid #111;
            padding: 15px 20px;
            box-shadow: inset 0 -2px 10px rgba(0, 0, 0, 0.3);
        }

        .scenes-panel-title {
            text-align: center;
            font-size: 12px;
            letter-spacing: 2px;
            color: #666;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .scenes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
            gap: 8px;
        }

        .scene-btn {
            background: linear-gradient(to bottom, #3a3a4c, #2a2a38);
            border: 1px solid #111;
            border-top: 1px solid #555;
            border-radius: 6px;
            color: #eee;
            padding: 8px 4px;
            font-size: 11px;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
            transition: all 0.1s;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .scene-btn:active,
        .scene-btn.playing {
            background: linear-gradient(to bottom, #1a1a24, #2a2a38);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.6);
            border-top: 1px solid #111;
            color: var(--accent);
        }

        .scene-btn .led {
            width: 12px;
            height: 4px;
            border-radius: 2px;
            margin-bottom: 6px;
        }

        .scene-btn.playing .led {
            background: var(--accent);
            box-shadow: 0 0 10px var(--accent);
        }

        .fader-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(70px, 1fr));
            gap: 6px;
            padding: 15px;
            background: #16161e;
        }

        .fader-ch {
            background: linear-gradient(to bottom, #252530, #15151c);
            border-radius: 8px;
            padding: 10px 4px 0 4px;
            /* Removed bottom padding for the handle */
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 340px;
            border: 1px solid #111;
            border-right: 1px solid #2a2a38;
            border-left: 1px solid #2a2a38;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.3);
            user-select: none;
            position: relative;
            transition: transform 0.2s, box-shadow 0.2s, border-color 0.2s;
        }

        .fader-ch.dragging {
            opacity: 0.5;
            transform: scale(0.95);
            border-color: var(--accent);
            box-shadow: 0 0 15px var(--accent);
        }

        .drag-handle {
            width: calc(100% + 8px);
            height: 16px;
            background: #2a2a38;
            margin-top: auto;
            border-radius: 0 0 7px 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
            cursor: grab;
            border-top: 1px solid #111;
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .fader-ch.linked-next {
            border-right: 2px solid var(--accent);
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
            margin-right: -1px;
        }

        .fader-ch.linked-prev {
            border-left: 2px solid var(--accent);
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
            margin-left: -1px;
        }

        .link-connector {
            width: 20px;
            height: 340px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .link-btn {
            width: 24px;
            height: 24px;
            background: #1a1a24;
            border: 1px solid #333;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #666;
            transition: all 0.2s;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        .link-btn:hover {
            border-color: var(--accent);
            color: var(--text);
        }

        .link-btn.active {
            background: var(--accent);
            border-color: var(--accent);
            color: white;
            box-shadow: 0 0 8px var(--accent);
        }

        .looper-btn {
            background: radial-gradient(circle at 30% 30%, #555, #222);
            border: 1px solid #000;
            border-top: 1px solid #666;
            width: 40px;
            height: 30px;
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 0 3px 5px rgba(0, 0, 0, 0.5);
            margin-bottom: 10px;
            transition: all 0.1s;
        }

        .looper-btn:active {
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.8);
            border-top: 1px solid #000;
            transform: translateY(2px);
        }

        .fader-ch input[type=range] {
            -webkit-appearance: slider-vertical;
            appearance: slider-vertical;
            width: 24px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 4px;
            flex: 1;
            margin: 15px 0;
            cursor: pointer;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.9);
            border: 1px solid #222;
        }

        .fader-ch input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 30px;
            width: 24px;
            background: linear-gradient(to right, #444, #777, #444);
            border-radius: 4px;
            border: 1px solid #111;
            border-top: 1px solid #999;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.6);
            cursor: ns-resize;
            border-bottom: 2px solid rgba(0, 0, 0, 0.8);
        }

        /* Neon accents based on index */
        .fader-ch:nth-child(4n+1) input[type=range]::-webkit-slider-thumb {
            border-bottom: 2px solid #ff4757;
        }

        .fader-ch:nth-child(4n+2) input[type=range]::-webkit-slider-thumb {
            border-bottom: 2px solid #7c4dff;
        }

        .fader-ch:nth-child(4n+3) input[type=range]::-webkit-slider-thumb {
            border-bottom: 2px solid #2ed573;
        }

        .fader-ch:nth-child(4n+4) input[type=range]::-webkit-slider-thumb {
            border-bottom: 2px solid #1e90ff;
        }

        .fader-val {
            background: #0a0a0f;
            color: #00ffcc;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            padding: 3px 6px;
            border-radius: 3px;
            border: 1px inset #222;
            margin-top: 5px;
            width: 45px;
            text-align: center;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.8);
            font-weight: bold;
        }

        /* --- PROFILE EDITOR SECTIONS --- */
        .section-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
            user-select: none;
        }

        .section-toggle h3 {
            margin: 0;
            font-size: 14px;
        }

        .section-toggle .arrow {
            transition: transform 0.2s;
            color: var(--text-dim);
        }

        .section-toggle .arrow.open {
            transform: rotate(90deg);
        }

        .section-body {
            padding: 10px 0;
        }

        .section-body.collapsed {
            display: none;
        }

        .kv-row {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.04);
        }

        .kv-row input,
        .kv-row select {
            width: auto;
            flex-shrink: 0;
        }

        .kv-row .kv-name {
            flex: 1;
            min-width: 80px;
        }

        .kv-row .kv-val {
            width: 70px;
        }

        .kv-row .kv-wide {
            flex: 2;
        }

        .kv-remove {
            background: rgba(255, 71, 87, 0.15);
            border: 1px solid var(--danger);
            color: var(--danger);
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            flex-shrink: 0;
        }

        .kv-remove:hover {
            background: var(--danger);
            color: white;
        }

        .add-row-btn {
            width: 100%;
            margin-top: 8px;
            border-style: dashed;
            background: transparent;
            color: var(--text-dim);
            border-color: var(--border);
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
        }

        .add-row-btn:hover {
            border-color: var(--accent);
            color: var(--accent);
        }

        .sub-card {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 6px;
            padding: 10px;
            margin-bottom: 8px;
        }

        .sub-card h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            color: var(--accent);
            font-weight: 500;
        }

        .mode-tag {
            display: inline-block;
            background: rgba(124, 77, 255, 0.15);
            color: var(--accent);
            padding: 2px 8px;
            border-radius: 3px;
            font-size: 11px;
            font-family: monospace;
        }

        /* --- MOBILE OPTIMIZATION --- */
        @media (max-width: 768px) {
            body {
                flex-direction: column-reverse;
                /* Nav at bottom */
                font-size: 16px;
            }

            #nav-panel {
                width: 100%;
                height: 80px;
                min-height: 80px;
                flex-shrink: 0;
                flex-direction: row;
                justify-content: space-around;
                padding: 10px 5px;
                padding-bottom: max(10px, env(safe-area-inset-bottom));
                border-right: none;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                background: rgba(15, 15, 19, 0.9);
                backdrop-filter: blur(25px);
                -webkit-backdrop-filter: blur(25px);
                z-index: 1000;
                gap: 2px;
            }

            #main-content {
                height: calc(100dvh - 80px);
                padding-top: max(10px, env(safe-area-inset-top));
                flex: 1;
            }

            .nav-btn {
                flex: 1;
                height: 100%;
                border-radius: 12px;
                background: transparent;
                font-size: 22px;
                border: none;
                flex-direction: column;
                gap: 0;
            }

            .nav-label {
                display: block;
            }

            .nav-btn.active {
                background: rgba(124, 77, 255, 0.12);
                color: var(--accent);
                box-shadow: inset 0 0 0 1px rgba(124, 77, 255, 0.2);
            }

            .nav-btn.active::after {
                content: '';
                position: absolute;
                top: 0;
                width: 20px;
                height: 3px;
                background: var(--accent);
                border-radius: 0 0 3px 3px;
                box-shadow: 0 0 10px var(--accent);
            }

            /* Responsive Grids */
            .row {
                flex-wrap: wrap;
            }

            .col {
                min-width: 100%;
                margin-bottom: 12px;
            }

            .view-panel {
                padding: 16px;
                padding-top: 24px;
            }

            .card {
                padding: 16px;
                border-radius: 16px;
                background: linear-gradient(165deg, #1b1b22, #15151b);
                border: 1px solid rgba(255, 255, 255, 0.08);
            }

            .sub-card {
                background: rgba(0, 0, 0, 0.2);
                border-radius: 12px;
                padding: 14px;
            }

            /* Stack Device Manager Rows */
            .device-row {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 12px;
                padding: 16px;
                background: linear-gradient(145deg, #1e1e26, #14141a);
                border-radius: 16px;
                border: 1px solid rgba(255, 255, 255, 0.08);
                box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
                margin-bottom: 16px;
                position: relative;
                overflow: hidden;
            }

            .device-row::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                height: 1px;
                background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            }

            .device-row input[type="text"],
            .device-row select:first-of-type {
                grid-column: span 2;
                font-size: 16px;
                background: rgba(0, 0, 0, 0.25);
                border-color: rgba(255, 255, 255, 0.1);
                border-radius: 10px;
                height: 48px;
            }

            .device-row select,
            .device-row input {
                width: 100%;
                height: 44px;
                margin-bottom: 0;
                border-radius: 8px;
                background: rgba(0, 0, 0, 0.2);
            }

            /* Custom Styled Checkboxes for Mobile */
            .device-row .checkbox-group {
                grid-column: span 2;
                display: flex;
                gap: 10px;
                margin-top: 5px;
            }

            .custom-checkbox {
                flex: 1;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 10px;
                background: rgba(255, 255, 255, 0.04);
                border: 1px solid rgba(255, 255, 255, 0.08);
                border-radius: 12px;
                height: 54px;
                cursor: pointer;
                user-select: none;
                transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                font-weight: 600;
                font-size: 13px;
            }

            .custom-checkbox.checked {
                background: rgba(124, 77, 255, 0.15);
                border-color: var(--accent);
                color: var(--accent);
                box-shadow: 0 0 15px rgba(124, 77, 255, 0.15);
            }

            .custom-checkbox input {
                display: none;
            }

            .device-row .kv-remove {
                grid-column: span 2;
                width: 100%;
                height: 44px;
                margin-top: 10px;
                background: rgba(255, 71, 87, 0.08);
                border-color: rgba(255, 71, 87, 0.2);
                border-radius: 10px;
                font-size: 18px;
            }

            /* Touch Targets */
            button,
            input[type="button"],
            input[type="submit"],
            input[type="reset"],
            .btn,
            .nav-btn,
            .add-row-btn,
            .kv-remove,
            .custom-checkbox,
            .toggle-switch {
                min-height: 44px;
                min-width: 44px;
                box-sizing: border-box;
            }

            /* Ensure content doesn't get hidden behind the nav bar */
            .view-panel>*:last-child {
                margin-bottom: 40px;
            }
        }

        .stepper-btn {
            width: 100%;
            background: #333;
            border: 1px solid var(--border);
            color: var(--accent);
            padding: 8px 0;
            cursor: pointer;
            font-size: 16px;
            border-radius: 4px;
            margin: 2px 0;
            transition: background 0.1s;
            touch-action: manipulation;
        }

        .stepper-btn:active {
            background: var(--accent);
            color: white;
        }
    </style>
</head>

<body>

    <div id="nav-panel">
        <div class="nav-btn" onclick="window.location.href='manager.html'" title="Return to Manager">üè†<span
                class="nav-label">Manager</span></div>
        <div class="nav-btn active" onclick="showView('stage')" title="Stage Manager">üèü<span
                class="nav-label">Stage</span></div>
        <div class="nav-btn" onclick="showView('roles')" title="Role Configuration">üé≠<span
                class="nav-label">Roles</span></div>
        <div class="nav-btn" onclick="showView('fixtures')" title="Fixture Editor">üí°<span
                class="nav-label">Editor</span></div>
        <div class="nav-btn" onclick="showView('test')" title="Live Test">üéö<span class="nav-label">Test</span></div>
        <div class="nav-btn" onclick="showView('presets')" title="Preset Manager">üíæ<span class="nav-label">Save</span>
        </div>
    </div>

    <div id="main-content">

        <!-- === ROLES CONFIGURATION === -->
        <div id="view-roles" class="view-panel">
            <div class="row" style="justify-content:space-between">
                <h2>Role Behavior & Buckets</h2>
                <div class="row">
                    <button class="btn" onclick="loadRolesConfig()">üîÑ Refresh</button>
                    <button class="btn primary" onclick="saveRolesConfig()">üíæ Save Roles</button>
                </div>
            </div>

            <div class="row" style="gap:20px; align-items: flex-start;">
                <!-- Column 1: Lead (Fluid) -->
                <div class="col card">
                    <div style="display:flex; align-items:center; gap:10px; margin-bottom:15px;">
                        <span style="font-size:24px;">üíß</span>
                        <h3 style="margin:0">Lead (Fluid)</h3>
                    </div>
                    <p style="font-size:11px; color:var(--text-dim); margin-top:-10px; margin-bottom:15px;">DMX
                        constraints for organic movement bases.</p>

                    <div id="lead-ranges-ui">
                        <!-- Ranges for X, Y, Z, Zoom -->
                    </div>
                </div>

                <!-- Column 2: Rythm -->
                <div class="col card">
                    <div style="display:flex; align-items:center; gap:10px; margin-bottom:15px;">
                        <span style="font-size:24px;">ü•Å</span>
                        <h3 style="margin:0">Rythm</h3>
                    </div>
                    <p style="font-size:11px; color:var(--text-dim); margin-top:-10px; margin-bottom:15px;">Shape &
                        Color buckets for transient triggers.</p>

                    <div class="row" style="gap:10px; align-items: flex-start;">
                        <div class="col" style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px;">
                            <h4 style="margin:0 0 8px 0; font-size:12px; color:var(--accent); text-align:center;">BOOTS
                            </h4>
                            <div id="rythm-boots-list"
                                style="min-height:50px; display:flex; flex-direction:column; gap:4px; margin-bottom:8px;">
                            </div>
                            <button class="add-row-btn" onclick="openRythmPicker('boots', 'shape')">+ Shape</button>
                            <button class="add-row-btn" onclick="openRythmPicker('boots', 'color')">+ Color</button>
                        </div>
                        <div class="col" style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px;">
                            <h4 style="margin:0 0 8px 0; font-size:12px; color:var(--accent); text-align:center;">CATS
                            </h4>
                            <div id="rythm-cats-list"
                                style="min-height:50px; display:flex; flex-direction:column; gap:4px; margin-bottom:8px;">
                            </div>
                            <button class="add-row-btn" onclick="openRythmPicker('cats', 'shape')">+ Shape</button>
                            <button class="add-row-btn" onclick="openRythmPicker('cats', 'color')">+ Color</button>
                        </div>
                        <div class="col" style="background: rgba(0,0,0,0.2); padding: 8px; border-radius: 6px;">
                            <h4 style="margin:0 0 8px 0; font-size:12px; color:var(--accent); text-align:center;">CHA
                            </h4>
                            <div id="rythm-cha-list"
                                style="min-height:50px; display:flex; flex-direction:column; gap:4px; margin-bottom:8px;">
                            </div>
                            <button class="add-row-btn" onclick="openRythmPicker('cha', 'shape')">+ Shape</button>
                            <button class="add-row-btn" onclick="openRythmPicker('cha', 'color')">+ Color</button>
                        </div>
                    </div>
                </div>


            </div>
        </div>

        <!-- === STAGE MANAGER === -->
        <div id="view-stage" class="view-panel active">
            <div class="row" style="justify-content:space-between">
                <h2>Stage Configuration</h2>
                <div class="row">
                    <button class="btn" onclick="loadStageConfig()">üîÑ Refresh</button>
                    <button class="btn primary" onclick="saveStageConfig()">üíæ Save Layout</button>
                </div>
            </div>

            <div class="card">
                <h3>Devices</h3>
                <div
                    style="margin-bottom: 10px; font-weight: bold; color: var(--text-dim); display: grid; grid-template-columns: 70px 1fr 80px 60px 60px 80px 50px 100px 40px; gap: 10px; padding: 0 10px;">
                    <div>Name</div>
                    <div>Profile</div>
                    <div>Cat</div>
                    <div>Addr</div>
                    <div>Offs</div>
                    <div>Loc</div>
                    <div>Invs</div>
                    <div>Behavior</div>
                    <div></div>
                </div>
                <div id="device-list"></div>
                <button class="btn" style="width:100%; margin-top:10px; border-style:dashed" onclick="addDevice()">+ Add
                    Device</button>
            </div>
        </div>

        <!-- === FIXTURE EDITOR === -->
        <div id="view-fixtures" class="view-panel">
            <div class="row" style="justify-content:space-between">
                <h2>Fixture Profile Editor</h2>
                <div class="row">
                    <select id="profile-select" onchange="loadFixtureProfile(this.value)" style="width:200px">
                        <option value="">-- Select Profile --</option>
                    </select>
                    <button class="btn" onclick="createNewProfile()">+ New</button>
                    <button class="btn primary" onclick="saveFixtureProfile()">üíæ Save Profile</button>
                </div>
            </div>

            <div id="editor-container" style="display:none">
                <div class="card">
                    <h3>Basic Info</h3>
                    <div class="row">
                        <div class="col">
                            <label>Filename (No Extension)</label>
                            <input type="text" id="fix-filename" readonly style="color:var(--text-dim)">
                        </div>
                        <div class="col">
                            <label>Fixture Type ID</label>
                            <input type="text" id="fix-type">
                        </div>
                        <div class="col">
                            <label>Display Name</label>
                            <input type="text" id="fix-name">
                        </div>
                    </div>
                </div>

                <div id="profile-sections"></div>

                <div class="card">
                    <h3>Raw JSON (Advanced)</h3>
                    <textarea id="json-editor" style="height:300px; font-family:monospace; color:#a29bfe"></textarea>
                    <button class="btn" style="margin-top:10px" onclick="parseJsonToUi()">Update UI from JSON</button>
                </div>
            </div>

            <div id="editor-empty-state" style="text-align:center; padding:50px; color:var(--text-dim)">
                Select or Create a profile to begin editing.
            </div>
        </div>

        <!-- === LIVE TEST === -->
        <div id="view-test" class="view-panel" style="padding:0; background:#111;">

            <div class="looper-topbar">
                <div class="toggle-switch">
                    <div class="switch-label on-text">On</div>
                    <div id="engine-toggle" class="switch-track on" onclick="toggleEngineVisual()">
                        <div class="switch-knob"></div>
                    </div>
                    <div class="switch-label off-text">Off</div>
                    <div
                        style="font-size: 10px; color: var(--accent); margin-left: 8px; margin-top: 2px; letter-spacing: 1px; font-weight: bold;">
                        ACTIVE ENGINE</div>
                </div>

                <div style="display:flex; align-items:center; gap:10px;">
                    <button class="btn accent" style="padding: 4px 10px; font-size:12px; height: 26px;"
                        onclick="saveGlobalPreset()">üíæ Save Vibe Preset</button>

                    <div style="font-size: 12px; color: var(--accent); font-weight: bold; letter-spacing: 1px;">DEVICE
                    </div>
                    <select id="test-dev-select" onchange="handleDeviceSelection(this.value)"
                        style="width:200px; background:#1a1a24; border-color:#333; color:#ccc;"></select>
                    <div id="conn-status"
                        style="color:var(--danger); font-size:12px; margin-left:15px; font-weight:bold;">üî¥ Disconnected
                    </div>
                </div>
            </div>

            <div class="scenes-panel">
                <div class="scenes-panel-title">SCENES</div>
                <div class="scenes-grid" id="scenes-grid">
                    <!-- Populated via JS -->
                </div>
            </div>

            <div id="test-faders" class="fader-grid" style="overflow-y:auto; flex:1;">
                <!-- Populated via JS -->
            </div>
        </div>

        <!-- === PRESET MANAGER === -->
        <div id="view-presets" class="view-panel">
            <div class="row" style="justify-content:space-between">
                <h2>Gobo / Preset Manager</h2>
                <div class="row">
                    <button class="btn" onclick="renderPresetsManager(true)">üîÑ Refresh</button>
                    <button class="btn primary" onclick="savePresetsFile()">üíæ Save Changes</button>
                </div>
            </div>

            <div class="card">
                <h3>Global Presets</h3>
                <div
                    style="margin-bottom: 10px; font-weight: bold; color: var(--text-dim); display: grid; grid-template-columns: 2fr 1fr 1fr 120px 50px; gap: 10px; padding: 0 10px;">
                    <div>Preset Name</div>
                    <div>Target Category</div>
                    <div>Vibe</div>
                    <div>Test Play</div>
                    <div></div>
                </div>
                <div id="presets-list"></div>
            </div>
        </div>

    </div>

    <script>
        // --- STATE ---
        const API_BASE = '/api/fixtures';
        let stageConfig = { devices: {} };
        let rolesConfig = {
            lead: {
                pos_x: [32, 96],
                pos_y: [32, 96],
                zoom: [0, 127],
                rot_z: [0, 127]
            },
            rythm: {
                boots: { shapes: [], colors: [] },
                cats: { shapes: [], colors: [] },
                cha: { shapes: [], colors: [] }
            }
        };
        let currentProfile = null;
        let availableProfiles = [];
        let ws = null;

        // Live Test Enhancements State
        let activeTestDevices = []; // Array of devNames
        let testProfiles = {}; // Key: type, Value: Profile object
        let testOrder = {}; // Key: devName, Value: Array of absAddr
        let linkedLinks = {}; // Key: devName, Value: Set of linked pairs (e.g. "addr1-addr2")
        let saveActiveChannels = {};
        let currentFaderValues = {};
        let looperState = {};
        let looperInterval = null;

        // --- INIT ---
        async function init() {
            await Promise.all([
                loadStageConfig(),
                loadProfileList(),
                loadRolesConfig()
            ]);
            initScenes();
            connectWs();
            renderPresetsManager();
        }

        // --- NAVIGATION ---
        function showView(viewId) {
            document.querySelectorAll('.view-panel').forEach(el => el.classList.remove('active'));
            document.getElementById('view-' + viewId).classList.add('active');
            document.querySelectorAll('.nav-btn').forEach(el => el.classList.remove('active'));
            event.currentTarget.classList.add('active');
        }

        // --- STAGE MANAGER ---
        async function loadStageConfig() {
            try {
                const res = await fetch(`${API_BASE}/stage_config.json`);
                if (!res.ok) throw new Error("No stage config");
                stageConfig = await res.json();

                if (!stageConfig.devices) stageConfig.devices = {};
                if (stageConfig.lasers) {
                    Object.assign(stageConfig.devices, stageConfig.lasers);
                    delete stageConfig.lasers;
                }

                renderDevices();
                populateTestDevices();
            } catch (e) {
                console.error(e);
                stageConfig = { devices: {} };
            }
        }

        async function saveStageConfig() {
            try {
                const res = await fetch(`${API_BASE}/stage_config.json`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(stageConfig, null, 4)
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                alert('Stage Configuration Saved!');
            } catch (e) {
                alert(`Error saving layout: ${e.message}`);
            }
        }

        // --- ROLES CONFIGURATION ---
        async function loadRolesConfig() {
            try {
                const res = await fetch(`/roles.json`);
                if (res.ok) {
                    const data = await res.json();
                    rolesConfig = Object.assign(rolesConfig, data);
                    console.log("Loaded rolesConfig:", rolesConfig);
                }
            } catch (e) {
                console.warn("No roles.json found, using defaults");
            }
            renderRolesUi();
        }

        async function saveRolesConfig() {
            try {
                const res = await fetch(`/roles.json`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(rolesConfig, null, 4)
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                alert('Roles Configuration Saved!');
            } catch (e) {
                alert(`Error saving roles: ${e.message}`);
            }
        }

        function renderRolesUi() {
            renderLeadRanges();
            renderRythmBuckets();
        }

        function renderLeadRanges() {
            const container = document.getElementById('lead-ranges-ui');
            container.innerHTML = '';

            const channels = ['pos_x', 'pos_y', 'zoom', 'rot_z', 'rot_x', 'rot_y'];
            channels.forEach(ch => {
                const range = rolesConfig.lead[ch] || [0, 255];
                const row = document.createElement('div');
                row.className = 'kv-row';
                row.innerHTML = `
                    <div class="kv-name" style="text-transform:uppercase; font-size:11px; color:var(--accent)">${ch.replace('_', ' ')}</div>
                    <input type="number" class="kv-val" value="${range[0]}" onchange="updateLeadRange('${ch}', 0, this.value)">
                    <span style="color:var(--text-dim)">-</span>
                    <input type="number" class="kv-val" value="${range[1]}" onchange="updateLeadRange('${ch}', 1, this.value)">
                `;
                container.appendChild(row);
            });
        }

        function updateLeadRange(ch, index, val) {
            if (!rolesConfig.lead[ch]) rolesConfig.lead[ch] = [0, 255];
            rolesConfig.lead[ch][index] = parseInt(val);
        }

        function renderRythmBuckets() {
            ['boots', 'cats', 'cha'].forEach(cat => {
                const list = document.getElementById(`rythm-${cat}-list`);
                list.innerHTML = '';

                const items = rolesConfig.rythm[cat];
                items.shapes.forEach(shape => {
                    list.appendChild(createBucketItem(cat, 'shapes', shape, 'üí†'));
                });
                items.colors.forEach(color => {
                    list.appendChild(createBucketItem(cat, 'colors', color, 'üé®'));
                });
            });
        }

        function createBucketItem(category, type, value, icon) {
            const el = document.createElement('div');
            el.style = "display:flex; align-items:center; justify-content:space-between; background:rgba(255,255,255,0.05); padding:4px 8px; border-radius:4px; font-size:11px;";
            el.innerHTML = `
                <span style="display:flex; align-items:center; gap:5px;">
                    <span>${icon}</span>
                    <span style="color:var(--text);">${value}</span>
                </span>
                <button onclick="removeFromBucket('${category}', '${type}', '${value}')" style="background:none; border:none; color:var(--danger); cursor:pointer; padding:0 4px;">√ó</button>
            `;
            return el;
        }

        async function openRythmPicker(category, type) {
            // Get available shapes or colors from the first laser fixture we find
            let options = [];
            const laserDev = Object.values(stageConfig.devices).find(d => d.type === 'ehaho_laser');
            if (!laserDev) {
                alert("No ehaho_laser found in stage config to pull patterns/colors from.");
                return;
            }

            try {
                const res = await fetch(`${API_BASE}/ehaho_laser.json`);
                const profile = await res.json();

                if (type === 'shape') {
                    options = Object.keys(profile.shapes || {});
                } else {
                    options = (profile.modes?.color_solid?.individual?.colors || []).map(c => c.name);
                }

                const choice = prompt(`Select ${type} to add to ${category}:\n\n` + options.join(', '));
                if (choice && options.includes(choice)) {
                    if (!rolesConfig.rythm[category][type + 's'].includes(choice)) {
                        rolesConfig.rythm[category][type + 's'].push(choice);
                        renderRythmBuckets();
                    }
                } else if (choice) {
                    alert("Invalid selection");
                }
            } catch (e) {
                alert("Error loading profile data: " + e.message);
            }
        }

        function removeFromBucket(category, type, value) {
            rolesConfig.rythm[category][type] = rolesConfig.rythm[category][type].filter(v => v !== value);
            renderRythmBuckets();
        }



        function renderDevices() {
            const list = document.getElementById('device-list');
            list.innerHTML = '';

            Object.entries(stageConfig.devices).forEach(([key, dev]) => {
                const row = document.createElement('div');
                row.className = 'device-row';

                let profOptions = availableProfiles.map(p =>
                    `<option value="${p.replace('.json', '')}" ${dev.type === p.replace('.json', '') ? 'selected' : ''}>${p}</option>`
                ).join('');

                row.innerHTML = `
                <input type="text" value="${key}" onchange="updateDeviceKey('${key}', this.value)" style="font-weight:bold" placeholder="Device Name">
                <select onchange="updateDeviceProp('${key}', 'type', this.value)">${profOptions}</select>
                
                <select onchange="updateDeviceProp('${key}', 'category', this.value)" title="Fixture Category">
                    <option value="laser" ${dev.category === 'laser' ? 'selected' : ''}>Laser</option>
                    <option value="light" ${dev.category === 'light' ? 'selected' : ''}>Light</option>
                    <option value="led_strip" ${dev.category === 'led_strip' ? 'selected' : ''}>LED Strip</option>
                    <option value="outlet" ${dev.category === 'outlet' ? 'selected' : ''}>Outlet</option>
                    <option value="generic" ${dev.category === 'generic' ? 'selected' : ''}>Generic</option>
                </select>
                
                <select onchange="updateDeviceProp('${key}', 'location', this.value)" title="Physical Location">
                    <option value="left" ${dev.location === 'left' ? 'selected' : ''}>Left</option>
                    <option value="right" ${dev.location === 'right' ? 'selected' : ''}>Right</option>
                    <option value="bottom" ${dev.location === 'bottom' ? 'selected' : ''}>Bottom</option>
                    <option value="top" ${dev.location === 'top' ? 'selected' : ''}>Top</option>
                    <option value="center" ${dev.location === 'center' ? 'selected' : ''}>Center</option>
                    <option value="n/a" ${dev.location === 'n/a' ? 'selected' : ''}>N/A</option>
                </select>

                <input type="number" value="${dev.address}" onchange="updateDeviceProp('${key}', 'address', parseInt(this.value))" title="DMX Address" placeholder="Addr">
                <input type="number" value="${dev.offset}" onchange="updateDeviceProp('${key}', 'offset', parseInt(this.value))" title="Channel Offset" placeholder="Offs">
                
                <div class="checkbox-group">
                    <label class="custom-checkbox ${dev.invert_x ? 'checked' : ''}">
                        <input type="checkbox" ${dev.invert_x ? 'checked' : ''} onchange="updateDeviceProp('${key}', 'invert_x', this.checked); this.parentElement.classList.toggle('checked', this.checked)"> 
                        ‚Üî Inv X
                    </label>
                    <label class="custom-checkbox ${dev.invert_y ? 'checked' : ''}">
                        <input type="checkbox" ${dev.invert_y ? 'checked' : ''} onchange="updateDeviceProp('${key}', 'invert_y', this.checked); this.parentElement.classList.toggle('checked', this.checked)"> 
                        ‚Üï Inv Y
                    </label>
                </div>

                <select onchange="updateDeviceProp('${key}', 'behavior', this.value); renderDevices()" title="Behavior Role">
                    <option value="lead" ${dev.behavior === 'lead' || !dev.behavior ? 'selected' : ''}>Lead (Fluid)</option>
                    <option value="rhythm" ${dev.behavior === 'rhythm' ? 'selected' : ''}>Rhythm</option>

                </select>

                <button class="kv-remove" onclick="deleteDevice('${key}')">√ó</button>
            `;
                list.appendChild(row);
            });
        }

        function addDevice() {
            const name = prompt("Device Name (e.g. L3):");
            if (name) {
                stageConfig.devices[name] = {
                    type: "ehaho_laser", category: "laser", address: 1, offset: 0,
                    location: "left", behavior: "lead",
                    invert_x: false, invert_y: false
                };
                renderDevices();
            }
        }

        function updateDeviceProp(key, prop, val) {
            stageConfig.devices[key][prop] = val;
        }

        function updateDeviceKey(oldKey, newKey) {
            if (oldKey === newKey) return;
            stageConfig.devices[newKey] = stageConfig.devices[oldKey];
            delete stageConfig.devices[oldKey];
            renderDevices();
        }

        function deleteDevice(key) {
            if (confirm(`Delete ${key}?`)) {
                delete stageConfig.devices[key];
                renderDevices();
            }
        }

        // --- FIXTURE EDITOR ---
        async function loadProfileList() {
            const res = await fetch(API_BASE);
            const files = await res.json();
            availableProfiles = files.filter(f => f !== 'stage_config.json');

            const sel = document.getElementById('profile-select');
            sel.innerHTML = '<option value="">-- Select Profile --</option>';
            availableProfiles.forEach(f => {
                const opt = document.createElement('option');
                opt.value = f;
                opt.innerText = f;
                sel.appendChild(opt);
            });

            // Re-render stage devices to populate dropdowns
            if (stageConfig.devices) renderDevices();
        }

        async function loadFixtureProfile(fname) {
            if (!fname) {
                document.getElementById('editor-container').style.display = 'none';
                document.getElementById('editor-empty-state').style.display = 'block';
                return;
            }

            const res = await fetch(`${API_BASE}/${fname}`);
            currentProfile = await res.json();

            document.getElementById('fix-filename').value = fname.replace('.json', '');
            document.getElementById('fix-type').value = currentProfile.type || '';
            document.getElementById('fix-name').value = currentProfile.name || '';
            syncUiToJson();

            document.getElementById('editor-container').style.display = 'block';
            document.getElementById('editor-empty-state').style.display = 'none';
            renderProfileUi();
        }

        async function saveFixtureProfile() {
            try {
                // Sync basic info fields into currentProfile
                if (currentProfile) {
                    currentProfile.type = document.getElementById('fix-type').value;
                    currentProfile.name = document.getElementById('fix-name').value;
                }
                const data = currentProfile || JSON.parse(document.getElementById('json-editor').value);

                const fname = document.getElementById('fix-filename').value + '.json';

                const res = await fetch(`${API_BASE}/${fname}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data, null, 4)
                });
                if (!res.ok) throw new Error(`HTTP ${res.status}`);
                alert(`Saved ${fname}`);
                loadProfileList();
            } catch (e) {
                alert("Error saving JSON: " + e.message);
            }
        }

        function createNewProfile() {
            const name = prompt("Filename (no extension):");
            if (!name) return;

            const countStr = prompt("How many DMX channels does this fixture use?");
            let count = parseInt(countStr) || 1;

            document.getElementById('fix-filename').value = name;
            currentProfile = {
                type: name,
                name: "New Fixture",
                channels: {},
                modes: {},
                defaults: {},
                calibration: {},
                shapes: {},
                ranges: {},
                dynamics: {},
                macros: {}
            };

            // Populate channels sequentially
            for (let i = 0; i < count; i++) {
                let roleName = `unassigned_ch${i + 1}`;
                currentProfile.channels[roleName] = i;
                currentProfile.defaults[roleName] = 0;
            }

            document.getElementById('fix-type').value = name;
            document.getElementById('fix-name').value = "New Fixture";
            syncUiToJson();

            document.getElementById('editor-container').style.display = 'block';
            document.getElementById('editor-empty-state').style.display = 'none';
            renderProfileUi();
        }

        function parseJsonToUi() {
            try {
                const data = JSON.parse(document.getElementById('json-editor').value);
                currentProfile = data;
                document.getElementById('fix-type').value = data.type || '';
                document.getElementById('fix-name').value = data.name || '';
                renderProfileUi();
            } catch (e) {
                alert("Invalid JSON");
            }
        }

        function syncUiToJson() {
            if (!currentProfile) return;
            document.getElementById('json-editor').value = JSON.stringify(currentProfile, null, 4);
        }

        // ==================== ENGINE SCHEMA ====================
        // Defines what the DMX engine supports per channel role
        const KNOWN_ROLES = [
            'pos_x', 'pos_y', 'zoom', 'rot_z', 'rot_x', 'rot_y',
            'color_solid', 'color_multi', 'pattern',
            'beam_fx', 'grating', 'drawing', 'drawing_delay',
            'strobe', 'generic', 'unassigned', 'dimmer',
            'mode', 'clip', 'group'
        ];

        // Role ‚Üí which modes the engine uses
        const ROLE_MODES = {
            pos_x: ['manual', 'wave'],
            pos_y: ['manual', 'wave'],
            zoom: ['manual', 'oscillation'],
            rot_z: ['manual', 'distortion'],
            rot_x: ['manual', 'distortion'],
            rot_y: ['manual', 'distortion'],
            color_solid: ['individual', 'cycle']
        };

        // Role ‚Üí which dynamics group applies
        const ROLE_DYNAMICS = {
            beam_fx: 'beam_fx'
        };

        // Dynamics group ‚Üí known parameter names
        const DYNAMICS_PARAMS = {
            beam_fx: ['high_threshold', 'base', 'mult']
        };

        // Known macro names the engine references
        const KNOWN_MACROS = [
            'wave_up', 'wave_down', 'wave_left', 'wave_right',
            'zoom_out_a', 'zoom_out_b', 'zoom_in_out', 'zoom_rot',
            'distort_up', 'distort_down', 'rot_fast', 'rot_frantic'
        ];

        // Role ‚Üí which calibration params apply
        const ROLE_CALIBRATION = {
            pos_x: ['center', 'left', 'right'],
            pos_y: ['center', 'top', 'bottom'],
            zoom: ['min_dmx', 'max_dmx', 'center'],
            rot_z: ['min_dmx', 'max_dmx', 'degree_min', 'degree_max'],
            rot_x: ['min_dmx', 'max_dmx', 'degree_min', 'degree_max'],
            rot_y: ['min_dmx', 'max_dmx', 'degree_min', 'degree_max'],
            beam_fx: ['base', 'max'],
            grating: ['base', 'max'],
            drawing: ['steps'],
            drawing_delay: ['steps'],
            dots: ['steps']
        };

        // Roles that use shapes
        const ROLES_WITH_SHAPES = ['pattern'];
        // Roles that are static (defaults only)
        const STATIC_ROLES = ['mode', 'clip', 'group', 'dimmer'];

        // ==================== SECTION VISIBILITY ====================
        function profileHasRolesFor(section) {
            const roles = Object.keys(currentProfile.channels || {});
            switch (section) {
                case 'macros': return roles.some(r => ROLE_MODES[r] && ROLE_MODES[r].length > 1);
                default: return true;
            }
        }

        // Track which sections are open
        let openSections = { shapes: false };

        function toggleSection(key) {
            if (openSections[key] === undefined) openSections[key] = false;
            openSections[key] = !openSections[key];
            renderProfileUi();
        }

        function makeSectionCard(key, title, bodyHtml) {
            const isOpen = openSections[key];
            return `<div class="card">
                <div class="section-toggle" onclick="toggleSection('${key}')">
                    <h3>${title}</h3>
                    <span class="arrow ${isOpen ? 'open' : ''}">‚ñ∂</span>
                </div>
                <div class="section-body ${isOpen ? '' : 'collapsed'}">${bodyHtml}</div>
            </div>`;
        }

        // ==================== MASTER RENDER ====================
        function renderProfileUi() {
            if (!currentProfile) return;
            const container = document.getElementById('profile-sections');
            const p = currentProfile;

            // Ensure all sections exist
            if (!p.channels) p.channels = {};
            if (!p.modes) p.modes = {};
            if (!p.defaults) p.defaults = {};
            if (!p.calibration) p.calibration = {};
            if (!p.shapes) p.shapes = {};
            if (!p.macros) p.macros = {};

            let html = '';

            // Unified Channels Block (Contains Defaults, Calibration, Modes, etc.)
            html += `<div class="card" style="padding:15px; margin-bottom:20px;">
                        <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:15px; border-bottom:1px solid var(--border); padding-bottom:10px;">
                            <h3 style="margin:0; color:var(--accent);">üì° Channels & Behaviors</h3>
                        </div>
                        ${renderChannelsSection()}
                     </div>`;

            container.innerHTML = html;
        }

        // ==================== CHANNELS ====================
        // ==================== CHANNELS (UNIFIED UI) ====================
        function renderChannelsSection() {
            const ch = currentProfile.channels;
            let html = '<div style="font-size:11px; color:var(--text-dim); margin-bottom:15px">Map physical DMX channels and configure their specific behaviors.</div>';

            // Sort by offset so they appear in physical channel order
            const sortedChannels = Object.entries(ch).sort((a, b) => a[1] - b[1]);

            sortedChannels.forEach(([role, offset]) => {
                const chNum = offset + 1; // 1-based display
                const isGeneric = role === 'generic' || role.startsWith('generic_');
                const isUnassigned = role === 'unassigned' || role.startsWith('unassigned_');

                html += `<div class="card" style="margin-bottom: 15px; padding: 12px; border-left: 4px solid var(--accent); background:rgba(255,255,255,0.01);">`;

                // --- HEADER ROW ---
                html += `<div class="kv-row" style="margin-bottom: 10px;">`;
                html += `<div style="width:100px; font-weight:bold; color:var(--accent); font-size:14px;">CH ${chNum} <div style="font-size:10px; color:#666; font-weight:normal;">(Offs ${offset})</div></div>`;

                const usedRoles = Object.keys(ch).filter(r => !r.startsWith('generic') && !r.startsWith('unassigned'));
                const availableRoles = KNOWN_ROLES.filter(r => !usedRoles.includes(r) || r === role || r === 'generic' || r === 'unassigned');

                html += `<select class="kv-wide" onchange="handleRoleChange('${role}', this.value)" style="margin-right:10px;">`;
                if (isGeneric) html += `<option value="${role}" selected>Generic</option>`;
                else if (isUnassigned) html += `<option value="${role}" selected>Unassigned</option>`;
                availableRoles.forEach(r => {
                    if (r === 'generic') html += `<option value="generic">Generic...</option>`;
                    else if (r === 'unassigned') html += `<option value="unassigned">Unassigned...</option>`;
                    else html += `<option value="${r}" ${r === role && !isGeneric && !isUnassigned ? 'selected' : ''}>${r}</option>`;
                });
                html += `</select>`;

                html += `<input type="number" value="${offset}" min="0" max="512" style="width:60px; font-size:11px;" onchange="updateProfileChannel('${role}', parseInt(this.value))" title="Manual Offset Adjust">`;
                html += `<button class="kv-remove" style="margin-left:8px; width:36px; height:36px;" onclick="removeProfileChannel('${role}')">√ó</button>`;
                html += `</div>`; // End Header Row

                // --- BODY ROW (Nested Configurations) ---
                html += `<div style="padding: 12px; background: rgba(0,0,0,0.3); border-radius: 6px; border: 1px solid rgba(255,255,255,0.05);">`;

                // 1. Default Value
                const defVal = currentProfile.defaults[role] !== undefined ? currentProfile.defaults[role] : 0;
                html += `<div class="kv-row" style="margin-bottom:10px;">
                            <label style="width:100px; margin:0; color:var(--text-dim);">Default Val</label>
                            <input class="kv-val" type="number" value="${defVal}" min="0" max="255" onchange="updateProfileDefault('${role}', parseInt(this.value))">
                         </div>`;

                // 2. Specific Configurations
                if (role.startsWith('dimmer')) html += getDimmerHtml(role);
                else if (role === 'strobe') html += getStrobeHtml(role);
                else if (role.startsWith('generic')) html += getGenericHtml(role);

                // 3. Calibration
                if (ROLE_CALIBRATION[role]) html += getCalibrationHtml(role);

                // 4. Modes & Macros
                if (ROLE_MODES[role]) html += getModesHtml(role);

                // 5. Shapes Dictionary (specifically for pattern roles)
                if (role === 'pattern') html += getShapesHtml(role);

                html += `</div></div>`; // End Body, End Card
            });

            html += `<button class="add-row-btn" style="padding:12px; font-weight:bold;" onclick="appendNewChannel()">+ Append Extra Channel</button>`;
            return html;
        }

        // --- SUB-GENERATORS FOR NESTED UI ---
        function getDimmerHtml(role) {
            const dim = currentProfile.dimmers || {};
            const cfg = dim[role] || { mode: 'binary', logic: 'normally_off', min: 0, max: 255, on_val: 255, off_val: 0 };
            let html = `<div style="margin-top:10px; border-top:1px dashed #333; padding-top:10px;">
                <h4 style="margin:0 0 10px 0; color:var(--accent); font-size:12px;">Dimmer Config</h4>
                <div class="row">
                    <label>Mode:</label>
                    <select style="width:100px" onchange="updateDimmerParam('${role}', 'mode', this.value)">
                        <option value="binary" ${cfg.mode === 'binary' ? 'selected' : ''}>Binary</option>
                        <option value="range" ${cfg.mode === 'range' ? 'selected' : ''}>Range</option>
                    </select>
                    <label>Logic:</label>
                    <select style="width:120px" onchange="updateDimmerParam('${role}', 'logic', this.value)">
                        <option value="normally_off" ${cfg.logic === 'normally_off' ? 'selected' : ''}>Normally Off</option>
                        <option value="normally_on" ${cfg.logic === 'normally_on' ? 'selected' : ''}>Normally On</option>
                    </select>
                </div>`;
            if (cfg.mode === 'binary') {
                html += `<div class="row" style="margin-top:8px">
                    <label>On Value:</label>
                    <input class="kv-val" type="number" value="${cfg.on_val}" style="width:60px" onchange="updateDimmerParam('${role}', 'on_val', parseInt(this.value))">
                    <label>Off Value:</label>
                    <input class="kv-val" type="number" value="${cfg.off_val}" style="width:60px" onchange="updateDimmerParam('${role}', 'off_val', parseInt(this.value))">
                </div>`;
            } else {
                html += `<div class="row" style="margin-top:8px">
                    <label>Range:</label>
                    <input class="kv-val" type="number" value="${cfg.min}" style="width:60px" onchange="updateDimmerParam('${role}', 'min', parseInt(this.value))">
                    <span style="color:var(--text-dim)">‚Äì</span>
                    <input class="kv-val" type="number" value="${cfg.max}" style="width:60px" onchange="updateDimmerParam('${role}', 'max', parseInt(this.value))">
                </div>`;
            }
            return html + '</div>';
        }

        function getStrobeHtml(role) {
            const strb = currentProfile.strobe || {};
            const cfg = strb[role] || { min: 0, max: 255 };
            return `<div style="margin-top:10px; border-top:1px dashed #333; padding-top:10px;">
                <h4 style="margin:0 0 10px 0; color:var(--accent); font-size:12px;">Strobe Range</h4>
                <div class="row">
                    <input class="kv-val" type="number" value="${cfg.min}" style="width:60px" onchange="updateStrobeParam('${role}', 'min', parseInt(this.value))">
                    <span style="color:var(--text-dim)">‚Äì</span>
                    <input class="kv-val" type="number" value="${cfg.max}" style="width:60px" onchange="updateStrobeParam('${role}', 'max', parseInt(this.value))">
                </div></div>`;
        }

        function getGenericHtml(role) {
            const gen = currentProfile.generic || {};
            const cfg = gen[role] || { min: 0, max: 255, default: 0, modifier: 'intensity', amount: 100 };
            return `<div style="margin-top:10px; border-top:1px dashed #333; padding-top:10px;">
                <h4 style="margin:0 0 10px 0; color:var(--accent); font-size:12px;">Generic Bounds</h4>
                <div class="device-row" style="display:grid; grid-template-columns: 1fr 1fr 1fr 1fr 1fr; gap:5px; background:none; padding:0; border:none;">
                    <div><label>Min</label><input type="number" value="${cfg.min}" onchange="updateGenericParam('${role}', 'min', parseInt(this.value))"></div>
                    <div><label>Max</label><input type="number" value="${cfg.max}" onchange="updateGenericParam('${role}', 'max', parseInt(this.value))"></div>
                    <div><label>Amount %</label><input type="number" value="${cfg.amount !== undefined ? cfg.amount : 100}" min="0" max="100" onchange="updateGenericParam('${role}', 'amount', parseInt(this.value))"></div>
                    <div><label>Modifier</label>
                        <select onchange="updateGenericParam('${role}', 'modifier', this.value)">
                            <option value="intensity" ${cfg.modifier === 'intensity' ? 'selected' : ''}>Intensity</option>
                            <option value="flux" ${cfg.modifier === 'flux' ? 'selected' : ''}>Flux</option>
                            <option value="bass" ${cfg.modifier === 'bass' ? 'selected' : ''}>Bass</option>
                            <option value="treble" ${cfg.modifier === 'treble' ? 'selected' : ''}>Treble</option>
                            <option value="crosstalk" ${cfg.modifier === 'crosstalk' ? 'selected' : ''}>Crosstalk</option>
                            <option value="none" ${cfg.modifier === 'none' ? 'selected' : ''}>None</option>
                        </select>
                    </div>
                </div></div>`;
        }

        function getCalibrationHtml(chName) {
            const cal = currentProfile.calibration || {};
            const params = cal[chName] || {};
            const knownParams = ROLE_CALIBRATION[chName] || [];

            let html = `<div style="margin-top:10px; border-top:1px dashed #333; padding-top:10px;">
                <h4 style="margin:0 0 10px 0; color:var(--accent); font-size:12px;">Calibration</h4>`;

            knownParams.forEach(paramName => {
                const paramVal = params[paramName] !== undefined ? params[paramName] : 0;
                const isStepped = paramName === 'steps';

                html += `<div class="kv-row" style="margin-bottom:4px;">
                    <label style="width:100px; margin:0; color:var(--text-dim); font-family:monospace;">${paramName}</label>`;

                if (isStepped) {
                    html += `<input class="kv-wide" type="text" value="${paramVal}" onchange="updateCalibrationParam('${chName}', '${paramName}', this.value)" placeholder="e.g. 63, 127">`;
                } else {
                    html += `<input class="kv-val" type="number" value="${paramVal}" onchange="updateCalibrationParam('${chName}', '${paramName}', parseFloat(this.value))">`;
                }

                html += `</div>`;
            });
            return html + '</div>';
        }

        function getModesHtml(chName) {
            const modeDefs = currentProfile.modes[chName] || {};
            const availableModes = ROLE_MODES[chName] || [];
            let html = `<div style="margin-top:15px; border-top:1px dashed #333; padding-top:10px;">
                <h4 style="margin:0 0 10px 0; color:var(--accent); font-size:12px;">Modes & Triggers</h4>`;

            Object.entries(modeDefs).forEach(([modeName, modeData]) => {
                const rangeMin = modeData.range ? modeData.range[0] : 0;
                const rangeMax = modeData.range ? modeData.range[1] : 255;

                const modeOpts = availableModes.map(m => {
                    const disp = m === 'manual' ? 'calibration' : m;
                    return `<option value="${m}" ${m === modeName ? 'selected' : ''}>${disp}</option>`;
                }).join('');

                html += `<div style="background: rgba(255,255,255,0.02); padding: 8px; border-radius: 4px; margin-bottom: 8px; border: 1px solid rgba(255,255,255,0.05);">`;
                html += `<div class="kv-row">
                    <select class="kv-name" style="width:120px;" onchange="renameProfileMode('${chName}', '${modeName}', this.value)">${modeOpts}</select>
                    <span style="color:var(--text-dim); font-size:11px">Range:</span>
                    <input class="kv-val" type="number" value="${rangeMin}" style="width:55px" onchange="updateProfileModeRange('${chName}', '${modeName}', 0, parseInt(this.value))">
                    <span style="color:var(--text-dim)">‚Äì</span>
                    <input class="kv-val" type="number" value="${rangeMax}" style="width:55px" onchange="updateProfileModeRange('${chName}', '${modeName}', 1, parseInt(this.value))">
                    <button class="kv-remove" onclick="removeProfileMode('${chName}', '${modeName}')">√ó</button>
                </div>`;

                // Clean Macro List Dropdown Logic
                if (modeData.macros !== undefined) {
                    const activeMacros = modeData.macros || [];
                    html += `<div style="margin-top:8px; padding-left:5px; font-size:11px;">
                        <div style="color:var(--text-dim); margin-bottom:4px;">Macros:</div>`;

                    if (activeMacros.length > 0) {
                        html += `<div style="display:flex; flex-wrap:wrap; gap:5px;">`;
                        html += activeMacros.map(m =>
                            `<span style="background:rgba(124,77,255,0.2); color:var(--accent); border:1px solid var(--accent); padding:2px 8px; border-radius:12px; display:flex; align-items:center; gap:5px;">
                                ${m} <span style="cursor:pointer; font-weight:bold; color:var(--danger);" onclick="removeModeMacro('${chName}', '${modeName}', '${m}')">√ó</span>
                            </span>`
                        ).join('');
                        html += `</div>`;
                    } else {
                        html += `<span style="color:#666; font-style:italic;">None active</span>`;
                    }

                    const availableMacros = KNOWN_MACROS.filter(m => !activeMacros.includes(m));
                    if (availableMacros.length > 0) {
                        html += `<div style="margin-top:8px; display:flex; gap:5px; align-items:center;">
                            <select id="add-macro-${chName}-${modeName}" style="flex:1; background:#222; border:1px solid #444; color:white; border-radius:4px; padding:4px;">
                                <option value="">-- Add Macro --</option>
                                ${availableMacros.map(m => `<option value="${m}">${m}</option>`).join('')}
                            </select>
                            <button class="btn primary" style="padding:4px 10px; font-size:11px;" onclick="addModeMacro('${chName}', '${modeName}')">+ Add</button>
                        </div>`;
                    }
                    html += `</div>`;
                }
                html += `</div>`;
            });

            // Add missing modes button
            const definedModes = Object.keys(modeDefs);
            const missingModes = availableModes.filter(m => !definedModes.includes(m));
            if (missingModes.length > 0) {
                html += `<div style="display:flex; gap:8px; margin-top:6px">
                     <select id="add-mode-${chName}" style="flex:1; background:#222; border:1px solid #444; color:white; border-radius:4px; padding:4px;">
                         ${missingModes.map(m => `<option value="${m}">${m === 'manual' ? 'calibrated' : m}</option>`).join('')}
                     </select>
                     <button class="btn" style="padding:4px 10px; font-size:11px;" onclick="addProfileMode('${chName}')">+ Add Mode</button>
                 </div>`;
            }
            return html + `</div>`;
        }
        function getShapesHtml(role) {
            const shapes = currentProfile.shapes || {};
            const isOpen = openSections.shapes;

            let html = `<div style="margin-top:15px; border-top:1px dashed #333; padding-top:10px;">
                <div style="display:flex; justify-content:space-between; align-items:center; cursor:pointer;" onclick="toggleSection('shapes')">
                    <h4 style="margin:0; color:var(--accent); font-size:12px;">üî∑ Shapes Dictionary</h4>
                    <span style="font-size:10px; color:var(--text-dim); transition: transform 0.2s; transform: ${isOpen ? 'rotate(90deg)' : 'none'};">‚ñ∂</span>
                </div>`;

            if (isOpen) {
                html += `<div style="margin-top:10px;">
                    <div style="font-size:11px; color:var(--text-dim); margin-bottom:8px">Shape name ‚Üí DMX pattern value</div>`;

                Object.entries(shapes).forEach(([name, val]) => {
                    html += `<div class="kv-row" style="margin-bottom:4px;">
                        <input class="kv-name" type="text" value="${name}" style="flex:1;" onchange="renameProfileShape('${name}', this.value)">
                        <input class="kv-val" type="number" value="${val}" min="0" max="255" style="width:60px;" onchange="updateProfileShape('${name}', parseInt(this.value))">
                        <button class="kv-remove" onclick="removeProfileShape('${name}')">√ó</button>
                    </div>`;
                });

                html += `<button class="add-row-btn" style="margin-top:5px; padding:4px 8px; font-size:11px;" onclick="addProfileShape()">+ Add Shape</button>
                </div>`;
            }

            return html + '</div>';
        }

        function handleRoleChange(oldRole, newValue) {
            let newRole = newValue;
            if (newValue === 'generic' || newValue === 'unassigned') {
                const suffix = prompt(`Enter a suffix for this ${newValue} channel (e.g., 'macro', 'fan'):\nLeave blank for standard '${newValue}'.`);
                if (suffix === null) {
                    renderProfileUi(); // Re-render to reset the dropdown visually
                    return;
                }
                newRole = suffix ? `${newValue}_${suffix.replace(/\s+/g, '_')}` : newValue;
            }
            renameProfileChannel(oldRole, newRole);
        }

        function appendNewChannel() {
            const offsets = Object.values(currentProfile.channels);
            const nextOffset = offsets.length > 0 ? Math.max(...offsets) + 1 : 0;
            const newRole = `unassigned_ch${nextOffset + 1}`;

            currentProfile.channels[newRole] = nextOffset;
            currentProfile.defaults[newRole] = 0;
            syncUiToJson();
            renderProfileUi();
        }

        function removeProfileChannel(role) {
            if (!confirm(`Remove channel "${role}"?`)) return;
            delete currentProfile.channels[role];
            delete currentProfile.defaults[role];
            delete currentProfile.modes[role];
            if (currentProfile.calibration) delete currentProfile.calibration[role];
            // Clean dynamics if no other channel uses the same group
            if (ROLE_DYNAMICS[role]) {
                const grp = ROLE_DYNAMICS[role];
                const othersUsingGroup = Object.keys(currentProfile.channels).some(r => ROLE_DYNAMICS[r] === grp);
                if (!othersUsingGroup) delete currentProfile.dynamics[grp];
            }
            syncUiToJson();
            renderProfileUi();
        }

        function renameProfileChannel(oldName, newName) {
            if (oldName === newName || !newName) return;
            if (currentProfile.channels[newName] !== undefined) {
                alert("Channel name already exists!");
                // Re-render to revert input
                renderProfileUi();
                return;
            }
            const val = currentProfile.channels[oldName];
            delete currentProfile.channels[oldName];
            currentProfile.channels[newName] = val;
            // Move related entries
            if (currentProfile.defaults && currentProfile.defaults[oldName] !== undefined) {
                currentProfile.defaults[newName] = currentProfile.defaults[oldName];
                delete currentProfile.defaults[oldName];
            }

            // Move Generic config
            if (currentProfile.generic && currentProfile.generic[oldName]) {
                currentProfile.generic[newName] = currentProfile.generic[oldName];
                delete currentProfile.generic[oldName];
            }

            // Move Strobe config
            if (currentProfile.strobe && currentProfile.strobe[oldName]) {
                currentProfile.strobe[newName] = currentProfile.strobe[oldName];
                delete currentProfile.strobe[oldName];
            }
            // Clear old role-specific data, recreate for new role
            delete currentProfile.modes[oldName];
            if (currentProfile.calibration) delete currentProfile.calibration[oldName];

            if (ROLE_MODES[newName] && !currentProfile.modes[newName]) {
                currentProfile.modes[newName] = {};
                ROLE_MODES[newName].forEach(m => {
                    currentProfile.modes[newName][m] = { range: m === 'manual' || m === 'individual' ? [0, 127] : [128, 255] };
                });
            }
            if (ROLE_CALIBRATION[newName] && !currentProfile.calibration[newName]) {
                currentProfile.calibration[newName] = {};
                ROLE_CALIBRATION[newName].forEach(p => {
                    let def = 0;
                    if (p === 'center') def = 64;
                    else if (p === 'max_dmx' || p === 'right' || p === 'bottom') def = 127;
                    else if (p === 'left' || p === 'top' || p === 'min_dmx') def = 0;
                    else if (p === 'range') def = 32;
                    currentProfile.calibration[newName][p] = def;
                });
            }
            syncUiToJson();
            renderProfileUi();
        }

        function updateProfileChannel(role, val) {
            currentProfile.channels[role] = val;
            syncUiToJson();
            renderProfileUi(); // Force re-sort if offset changed manually
        }

        // ==================== MODES ====================

        function addProfileMode(chName) {
            const sel = document.getElementById('add-mode-' + chName);
            if (!sel) return;
            const modeName = sel.value;
            if (!modeName) return;
            if (!currentProfile.modes[chName]) currentProfile.modes[chName] = {};

            const isFirst = modeName === 'manual' || modeName === 'individual';
            currentProfile.modes[chName][modeName] = { range: isFirst ? [0, 127] : [128, 255] };

            // Auto-add macros array for effect modes
            if (modeName !== 'manual' && modeName !== 'individual' && modeName !== 'cycle') {
                currentProfile.modes[chName][modeName].macros = [];
            }
            syncUiToJson();
            renderProfileUi();
        }

        function removeProfileMode(chName, modeName) {
            delete currentProfile.modes[chName][modeName];
            if (Object.keys(currentProfile.modes[chName]).length === 0) {
                delete currentProfile.modes[chName];
            }
            syncUiToJson();
            renderProfileUi();
        }

        function renameProfileMode(chName, oldName, newName) {
            if (oldName === newName || !newName) return;
            currentProfile.modes[chName][newName] = currentProfile.modes[chName][oldName];
            delete currentProfile.modes[chName][oldName];
            syncUiToJson();
            renderProfileUi();
        }

        function updateProfileModeRange(chName, modeName, idx, val) {
            if (!currentProfile.modes[chName][modeName].range) currentProfile.modes[chName][modeName].range = [0, 255];
            currentProfile.modes[chName][modeName].range[idx] = val;
            syncUiToJson();
        }

        function addModeMacro(chName, modeName) {
            const sel = document.getElementById(`add-macro-${chName}-${modeName}`);
            if (!sel || !sel.value) return;
            const macro = sel.value;
            const mode = currentProfile.modes[chName][modeName];
            if (!mode.macros) mode.macros = [];
            if (!mode.macros.includes(macro)) mode.macros.push(macro);
            syncUiToJson();
            renderProfileUi(); // Re-render to show new pill
        }

        function removeModeMacro(chName, modeName, macro) {
            const mode = currentProfile.modes[chName][modeName];
            if (mode.macros) {
                mode.macros = mode.macros.filter(m => m !== macro);
            }
            syncUiToJson();
            renderProfileUi(); // Re-render to remove pill
        }

        function updateProfileModeColors(chName, modeName, val) {
            try {
                currentProfile.modes[chName][modeName].colors = JSON.parse(val);
                syncUiToJson();
            } catch (e) {
                alert("Invalid JSON for colors");
            }
        }


        function updateProfileDefault(role, val) {
            currentProfile.defaults[role] = val;
            syncUiToJson();
        }

        function updateCalibrationParam(chName, paramName, val) {
            if (!currentProfile.calibration[chName]) currentProfile.calibration[chName] = {};
            currentProfile.calibration[chName][paramName] = val;
            syncUiToJson();
        }


        function addProfileShape() {
            const name = prompt("Shape name (e.g. circle, star, dot1):");
            if (!name) return;
            if (!currentProfile.shapes) currentProfile.shapes = {};
            currentProfile.shapes[name] = 0;
            syncUiToJson();
            renderProfileUi();
        }

        function removeProfileShape(name) {
            delete currentProfile.shapes[name];
            syncUiToJson();
            renderProfileUi();
        }

        function renameProfileShape(oldName, newName) {
            if (oldName === newName || !newName) return;
            currentProfile.shapes[newName] = currentProfile.shapes[oldName];
            delete currentProfile.shapes[oldName];
            syncUiToJson();
        }

        function updateProfileShape(name, val) {
            currentProfile.shapes[name] = val;
            syncUiToJson();
        }

        // ==================== MACROS ====================
        function renderMacrosSection() {
            const macros = currentProfile.macros || {};
            let html = '<div style="font-size:11px; color:var(--text-dim); margin-bottom:8px">Macro name ‚Üí DMX trigger value</div>';

            // Show all known macros with current values
            KNOWN_MACROS.forEach(name => {
                const val = macros[name] !== undefined ? macros[name] : '';
                const isActive = macros[name] !== undefined;
                html += `<div class="kv-row">
                    <label class="custom-checkbox small ${isActive ? 'checked' : ''}" style="flex:1">
                        <input type="checkbox" ${isActive ? 'checked' : ''} onchange="toggleMacro('${name}', this.checked); this.parentElement.classList.toggle('checked', this.checked)">
                        <span class="kv-name" style="font-family:monospace; color:${isActive ? 'var(--accent)' : 'var(--text-dim)'}; margin:0">${name}</span>
                    </label>
                    <input class="kv-val" type="number" value="${val}" min="0" max="255" style="width:60px" onchange="updateProfileMacro('${name}', parseInt(this.value))">
                </div>`;
            });
            return html;
        }

        function toggleMacro(name, checked) {
            if (checked) {
                currentProfile.macros[name] = 128;
            } else {
                delete currentProfile.macros[name];
            }
            syncUiToJson();
            renderProfileUi();
        }

        function updateProfileMacro(name, val) {
            currentProfile.macros[name] = val;
            syncUiToJson();
        }

        function updateGenericParam(role, param, val) {
            if (!currentProfile.generic) currentProfile.generic = {};
            if (!currentProfile.generic[role]) currentProfile.generic[role] = { min: 0, max: 255, default: 0, modifier: 'intensity', amount: 100 };
            currentProfile.generic[role][param] = val;
            syncUiToJson();
        }

        function updateStrobeParam(role, param, val) {
            if (!currentProfile.strobe) currentProfile.strobe = {};
            if (!currentProfile.strobe[role]) currentProfile.strobe[role] = { min: 0, max: 255 };
            currentProfile.strobe[role][param] = val;
            syncUiToJson();
        }

        function updateDimmerParam(key, param, val) {
            if (!currentProfile.dimmers) currentProfile.dimmers = {};
            if (!currentProfile.dimmers[key]) {
                currentProfile.dimmers[key] = { mode: 'binary', logic: 'normally_off', min: 0, max: 255, on_val: 255, off_val: 0 };
            }
            currentProfile.dimmers[key][param] = val;
            syncUiToJson();
            renderProfileUi();
        }


        // --- LIVE TEST ---
        function connectWs() {
            ws = new WebSocket(`ws://${window.location.hostname}:8765`);
            ws.onopen = () => {
                document.getElementById('conn-status').innerText = "üü¢ Connected";
                document.getElementById('conn-status').style.color = "var(--success)";
            };
            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);
                    if (msg.type === "force_refresh") {
                        window.location.reload();
                    }
                } catch (e) { }
            };
            ws.onclose = () => {
                document.getElementById('conn-status').innerText = "üî¥ Disconnected";
                document.getElementById('conn-status').style.color = "var(--danger)";
                setTimeout(connectWs, 2000);
            };
        }

        function populateTestDevices() {
            const sel = document.getElementById('test-dev-select');
            sel.innerHTML = '';

            let allDevices = {};
            if (stageConfig.lasers) Object.assign(allDevices, stageConfig.lasers);
            if (stageConfig.devices) Object.assign(allDevices, stageConfig.devices);

            Object.keys(allDevices).forEach(k => {
                const opt = document.createElement('option');
                opt.value = k;
                opt.innerText = k;
                sel.appendChild(opt);
            });
            if (sel.options.length > 0) handleDeviceSelection(sel.options[0].value);
        }

        // --- LOOPER ENGINE ---
        isEngineVisualOn = true;

        const SCENE_MAPPINGS = {
            'hold': 'HOLD',
            'scroll': 'SCROLL',
            'chase': 'CHASE',
            'lissajous': 'LISSAJOUS'
        };

        function initScenes() {
            const grid = document.getElementById('scenes-grid');
            if (!grid) return;
            grid.innerHTML = '';

            // Only 4 buttons now
            Object.keys(SCENE_MAPPINGS).forEach((scene) => {
                const btn = document.createElement('div');
                btn.className = 'scene-btn';
                btn.style.height = '60px'; // Make them bigger since there are fewer
                btn.innerHTML = `<div class="led"></div><div style="font-size:10px; font-weight:bold; margin-top:5px;">${scene.toUpperCase()}</div>`;
                btn.onclick = () => {
                    document.querySelectorAll('.scene-btn').forEach(el => el.classList.remove('playing'));
                    btn.classList.add('playing');

                    if (ws && ws.readyState === 1) {
                        ws.send(JSON.stringify({ type: 'trigger_scene', scene: scene }));
                    }

                    setTimeout(() => btn.classList.remove('playing'), 500);
                };
                grid.appendChild(btn);
            });
        }

        function applyLocalScene(sceneName) {
            const devName = document.getElementById('test-dev-select').value;
            let allDevices = stageConfig.devices || {};
            const dev = allDevices[devName];
            if (!dev || !currentProfile || !currentProfile.channels) return;

            const mapping = SCENE_MAPPINGS[sceneName];
            if (!mapping) return;

            Object.entries(currentProfile.channels).forEach(([role, val]) => {
                if (mapping[role]) {
                    const offset = typeof val === 'object' ? val.offset : val;
                    const absAddr = dev.address + dev.offset + offset;

                    const minVal = mapping[role][0];
                    const maxVal = mapping[role][1];

                    if (minVal === maxVal) {
                        // Just hold
                        const disp = document.getElementById(`disp-${absAddr}`);
                        if (disp) disp.value = minVal;
                        updateDmxState(absAddr, minVal);
                    } else {
                        // Range sequence
                        const disp = document.getElementById(`disp-${absAddr}`);
                        if (disp) disp.value = `${minVal}-${maxVal}`;
                        generateRangeSequence(absAddr, minVal, maxVal);
                    }
                }
            });
        }

        function toggleEngineVisual() {
            const track = document.getElementById('engine-toggle');
            isEngineVisualOn = !isEngineVisualOn;

            if (isEngineVisualOn) {
                track.classList.add('on');
                // Clear overrides for the currently selected device
                const devName = document.getElementById('test-dev-select').value;
                if (ws && ws.readyState === 1 && devName) {
                    ws.send(JSON.stringify({ type: 'clear_overrides', device: devName }));

                    // Also clear local UI fader values for this device? 
                    // Let's at least reset the currentFaderValues cache for those addresses
                    // but we don't know the exact addresses easily without re-scanning profile
                }
            } else {
                track.classList.remove('on');
            }
        }

        function toggleLooper(addr) {
            if (!looperState[addr]) looperState[addr] = { mode: 'idle', frames: [], playIdx: 0, lastVal: currentFaderValues[addr] || 0 };

            const state = looperState[addr];
            const led = document.getElementById(`led-${addr}`);

            if (state.mode === 'idle') {
                state.mode = 'rec';
                state.frames = [currentFaderValues[addr] || 0];
                led.className = 'led red';
            } else if (state.mode === 'rec') {
                state.mode = 'play';
                state.playIdx = 0;
                led.className = 'led green';
            } else if (state.mode === 'play') {
                state.mode = 'idle';
                led.className = 'led';
                state.frames = [];
            }
        }

        function looperTick() {
            let overridesToSend = {};
            let hasOverrides = false;

            Object.entries(looperState).forEach(([addrStr, state]) => {
                const addr = parseInt(addrStr);

                if (state.mode === 'rec') {
                    state.frames.push(currentFaderValues[addr] || 0);
                } else if (state.mode === 'play' && state.frames.length > 0) {
                    const val = state.frames[state.playIdx];
                    if (val !== undefined && val !== state.lastVal) {
                        currentFaderValues[addr] = val;
                        state.lastVal = val;

                        const input = document.getElementById(`input-${addr}`);
                        const disp = document.getElementById(`disp-${addr}`);
                        if (input) input.value = val;
                        if (disp) {
                            disp.value = val;
                            disp.innerText = val; // fallback
                        }

                        overridesToSend[addr] = val;
                        hasOverrides = true;
                    }

                    state.playIdx++;
                    if (state.playIdx >= state.frames.length) {
                        state.playIdx = 0;
                    }
                }
            });

            if (hasOverrides && ws && ws.readyState === 1) {
                const overridesArray = Object.entries(currentFaderValues).map(([a, v]) => ({
                    address: parseInt(a),
                    value: v
                }));
                ws.send(JSON.stringify({
                    type: 'laser_override',
                    overrides: overridesArray
                }));
            }
        }

        async function handleDeviceSelection(devName) {
            if (!devName) return;
            if (activeTestDevices.includes(devName)) return;

            if (activeTestDevices.length > 0) {
                if (confirm(`Add ${devName} to current view?`)) {
                    activeTestDevices.push(devName);
                } else {
                    activeTestDevices = [devName];
                }
            } else {
                activeTestDevices = [devName];
            }
            await renderTestFaders();
        }

        async function renderTestFaders() {
            const container = document.getElementById('test-faders');
            container.innerHTML = '';
            container.style.display = 'flex';
            container.style.flexDirection = 'column'; // Vertical stack of horizontal rows
            container.style.gap = '20px';
            container.style.padding = '20px';

            let allDevices = stageConfig.devices || {};

            for (const devName of activeTestDevices) {
                const dev = allDevices[devName];
                if (!dev) continue;

                let profile = testProfiles[dev.type];
                if (!profile) {
                    try {
                        const res = await fetch(`${API_BASE}/${dev.type}.json`);
                        if (res.ok) {
                            profile = await res.json();
                            testProfiles[dev.type] = profile;
                        } else continue;
                    } catch (e) { console.error("Profile load error", e); continue; }
                }

                const deviceSection = document.createElement('div');
                deviceSection.style.display = 'flex';
                deviceSection.style.flexDirection = 'column';
                deviceSection.style.gap = '5px';

                const deviceHeader = document.createElement('div');
                deviceHeader.style.display = 'flex';
                deviceHeader.style.justifyContent = 'space-between';
                deviceHeader.style.alignItems = 'center';
                deviceHeader.style.borderBottom = '1px solid #333';
                deviceHeader.style.paddingBottom = '5px';
                deviceHeader.style.marginBottom = '5px';
                deviceHeader.innerHTML = `
                    <div style="color:var(--accent); font-weight:bold; font-size:14px; letter-spacing:1px;">${devName} (${dev.type})</div>
                    <button onclick="removeActiveTestDevice('${devName}')" style="background:none; border:none; color:var(--danger); cursor:pointer; font-size:12px;">‚úï Close</button>
                `;
                deviceSection.appendChild(deviceHeader);

                const fadersRow = document.createElement('div');
                fadersRow.style.display = 'flex';
                fadersRow.style.flexWrap = 'nowrap';
                fadersRow.style.alignItems = 'flex-start';
                fadersRow.style.gap = '0';
                fadersRow.style.overflowX = 'auto';

                // Get standard sorted addresses
                const standardOrder = Object.entries(profile.channels).sort((a, b) => {
                    const offA = typeof a[1] === 'object' ? a[1].offset : a[1];
                    const offB = typeof b[1] === 'object' ? b[1].offset : b[1];
                    return offA - offB;
                }).map(([role, val]) => {
                    const offset = typeof val === 'object' ? val.offset : val;
                    return { role, addr: dev.address + dev.offset + offset };
                });

                // Maintain persistent order per device
                if (!testOrder[devName] || testOrder[devName].length !== standardOrder.length) {
                    testOrder[devName] = standardOrder;
                }
                if (!linkedLinks[devName]) linkedLinks[devName] = new Set();

                const order = testOrder[devName];
                const links = linkedLinks[devName];

                order.forEach((ch, idx) => {
                    const absAddr = ch.addr;
                    const role = ch.role;

                    if (!looperState[absAddr]) {
                        looperState[absAddr] = { mode: 'idle', frames: [], playIdx: 0, lastVal: 0 };
                    }

                    const wrapper = document.createElement('div');
                    wrapper.className = 'fader-ch';
                    wrapper.dataset.addr = absAddr;
                    wrapper.dataset.index = idx;
                    wrapper.dataset.devName = devName;

                    const isLinkedNext = links.has(`${absAddr}-${order[idx + 1]?.addr}`);
                    const isLinkedPrev = links.has(`${order[idx - 1]?.addr}-${absAddr}`);

                    if (isLinkedNext) wrapper.classList.add('linked-next');
                    if (isLinkedPrev) wrapper.classList.add('linked-prev');

                    // Drag Events
                    wrapper.addEventListener('dragstart', (e) => {
                        wrapper.classList.add('dragging');
                        e.dataTransfer.setData('text/plain', JSON.stringify({ devName, idx }));
                    });
                    wrapper.addEventListener('dragend', () => {
                        wrapper.classList.remove('dragging');
                        wrapper.removeAttribute('draggable');
                    });
                    wrapper.addEventListener('dragover', (e) => e.preventDefault());
                    wrapper.addEventListener('drop', (e) => {
                        e.preventDefault();
                        const data = JSON.parse(e.dataTransfer.getData('text/plain'));
                        if (data.devName !== devName) return; // Only allow reorder within same device group
                        const fromIdx = data.idx;
                        const toIdx = idx;
                        if (fromIdx !== toIdx) {
                            const item = order.splice(fromIdx, 1)[0];
                            order.splice(toIdx, 0, item);
                            renderTestFaders();
                        }
                    });

                    let shortRole = role.replace(/_/g, ' ').toUpperCase();
                    if (shortRole.length > 10) shortRole = shortRole.substring(0, 8) + '..';

                    wrapper.innerHTML = `
                        <div style="min-height: 40px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 4px;">
                            <input type="checkbox" id="save-active-${absAddr}" ${saveActiveChannels[absAddr] ? 'checked' : ''} 
                                onchange="saveActiveChannels[${absAddr}] = this.checked"
                                title="Include in Save"
                                style="margin:0; cursor:pointer; accent-color:var(--accent);">
                            <div id="led-${absAddr}" class="led"></div>
                            <button class="looper-btn" onclick="toggleLooper(${absAddr})"></button>
                        </div>
                        
                        <div style="font-size:10px; color:#aaa; margin-bottom:5px">CH ${absAddr}</div>
                        
                        <input type="range" id="input-${absAddr}" min="0" max="255" value="${currentFaderValues[absAddr] || 0}" 
                            oninput="updateDmxState(${absAddr}, this.value)"
                            style="flex:1;">
                        
                        <input id="disp-${absAddr}" type="text" value="${currentFaderValues[absAddr] || 0}" class="fader-val" style="background:transparent; border:none; text-align:center; color:var(--text); width:100%; font-family:inherit; outline:none; border-bottom:1px solid #333;" 
                            onkeydown="handleFaderInput(event, ${absAddr}, this)" 
                            onblur="syncFaderInput(${absAddr}, this)"
                            title="Enter value (0-255) or loop range (0-100)">
                        <div style="font-size:9px; margin-top:5px; text-align:center; color:#888; letter-spacing:1px; line-height: 1.1; margin-bottom: 5px;">${shortRole}</div>
                        
                        <div class="drag-handle" 
                            onmousedown="this.parentElement.setAttribute('draggable', 'true')" 
                            onmouseup="this.parentElement.removeAttribute('draggable')" 
                            onmouseleave="this.parentElement.removeAttribute('draggable')">‚â°</div>
                    `;
                    fadersRow.appendChild(wrapper);

                    // Add Link Button after if not last
                    if (idx < order.length - 1) {
                        const connector = document.createElement('div');
                        connector.className = 'link-connector';
                        const nextAddr = order[idx + 1].addr;
                        const linkKey = `${absAddr}-${nextAddr}`;
                        const isActive = links.has(linkKey);

                        connector.innerHTML = `
                            <button class="link-btn ${isActive ? 'active' : ''}" onclick="toggleFaderLink('${devName}', '${linkKey}')" title="Link Sliders">
                                üîó
                            </button>
                        `;
                        fadersRow.appendChild(connector);
                    }
                });
                deviceSection.appendChild(fadersRow);
                container.appendChild(deviceSection);
            }

            if (looperInterval) clearInterval(looperInterval);
            looperInterval = setInterval(looperTick, 1000 / 30);
        }

        async function removeActiveTestDevice(devName) {
            activeTestDevices = activeTestDevices.filter(d => d !== devName);
            await renderTestFaders();
        }

        function toggleFaderLink(devName, linkKey) {
            const links = linkedLinks[devName];
            if (links.has(linkKey)) links.delete(linkKey);
            else links.add(linkKey);
            renderTestFaders();
        }

        function handleFaderInput(e, addr, el) {
            if (e.key === 'ArrowUp') {
                e.preventDefault();
                let v = parseInt(el.value) || 0;
                let newVal = Math.min(255, v + 1);
                el.value = newVal;
                updateDmxState(addr, newVal);
                document.getElementById(`input-${addr}`).value = newVal;
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                let v = parseInt(el.value) || 0;
                let newVal = Math.max(0, v - 1);
                el.value = newVal;
                updateDmxState(addr, newVal);
                document.getElementById(`input-${addr}`).value = newVal;
            } else if (e.key === 'Enter') {
                e.preventDefault();
                syncFaderInput(addr, el);
                el.blur();
            }
        }

        function syncFaderInput(addr, el) {
            const valStr = el.value.trim();
            if (valStr.includes(',') || valStr.includes('-')) {
                generateMultiSequence(addr, valStr);
                return;
            }

            let v = parseInt(valStr);
            if (!isNaN(v)) {
                v = Math.max(0, Math.min(255, v));
                updateDmxState(addr, v);
            } else {
                el.value = currentFaderValues[addr] || 0;
            }
        }

        function generateMultiSequence(addr, input) {
            const segments = input.split(',').map(s => s.trim()).filter(s => s.length > 0);
            let frames = [];
            const stepsPerRange = 45; // ~1.5s per sweep at 30fps
            const holdFrames = 30;    // ~1s hold for discrete values

            segments.forEach(seg => {
                if (seg.includes('-')) {
                    const parts = seg.split('-');
                    let start = parseInt(parts[0]);
                    let end = parseInt(parts[1]);
                    if (!isNaN(start) && !isNaN(end)) {
                        start = Math.max(0, Math.min(255, start));
                        end = Math.max(0, Math.min(255, end));
                        // Ramp Up
                        for (let i = 0; i <= stepsPerRange; i++) {
                            frames.push(Math.round(start + (end - start) * (i / stepsPerRange)));
                        }
                        // Ramp Down
                        for (let i = stepsPerRange - 1; i > 0; i--) {
                            frames.push(Math.round(start + (end - start) * (i / stepsPerRange)));
                        }
                    }
                } else {
                    let v = parseInt(seg);
                    if (!isNaN(v)) {
                        v = Math.max(0, Math.min(255, v));
                        for (let i = 0; i < holdFrames; i++) {
                            frames.push(v);
                        }
                    }
                }
            });

            if (frames.length === 0) return;

            if (!looperState[addr]) {
                looperState[addr] = { mode: 'idle', frames: [], playIdx: 0, lastVal: frames[0] };
            }
            looperState[addr].frames = frames;
            looperState[addr].playIdx = 0;
            looperState[addr].mode = 'play';

            const led = document.getElementById(`led-${addr}`);
            if (led) led.className = 'led green';
        }

        function updateDmxState(addr, val, skipLinked = false) {
            const intVal = parseInt(val);

            // Find which device this addr belongs to
            let devName = null;
            let allDevices = stageConfig.devices || {};
            for (const name of activeTestDevices) {
                const dev = allDevices[name];
                const profile = testProfiles[dev.type];
                if (!profile) continue;

                const offsets = Object.values(profile.channels).map(v => typeof v === 'object' ? v.offset : v);
                const minAddr = dev.address + dev.offset + Math.min(...offsets);
                const maxAddr = dev.address + dev.offset + Math.max(...offsets);

                if (addr >= minAddr && addr <= maxAddr) {
                    devName = name;
                    break;
                }
            }

            if (!devName) {
                // Fallback for cases where it's not in a current profile (shouldn't happen with current logic)
                currentFaderValues[addr] = intVal;
                return;
            }

            // Find Linked Group
            let group = [addr];
            if (!skipLinked && linkedLinks[devName]) {
                const order = testOrder[devName] || [];
                const links = linkedLinks[devName];

                // Expand forwards
                let curr = addr;
                while (true) {
                    const idx = order.findIndex(o => o.addr === curr);
                    const next = order[idx + 1];
                    if (next && links.has(`${curr}-${next.addr}`)) {
                        group.push(next.addr);
                        curr = next.addr;
                    } else break;
                }
                // Expand backwards
                curr = addr;
                while (true) {
                    const idx = order.findIndex(o => o.addr === curr);
                    const prev = order[idx - 1];
                    if (prev && links.has(`${prev.addr}-${curr}`)) {
                        group.unshift(prev.addr);
                        curr = prev.addr;
                    } else break;
                }
            }

            group.forEach(targetAddr => {
                currentFaderValues[targetAddr] = intVal;
                saveActiveChannels[targetAddr] = true;

                const checkbox = document.getElementById(`save-active-${targetAddr}`);
                if (checkbox) checkbox.checked = true;

                const disp = document.getElementById(`disp-${targetAddr}`);
                if (disp) {
                    disp.value = intVal;
                    disp.innerText = intVal;
                }
                const input = document.getElementById(`input-${targetAddr}`);
                if (input) input.value = intVal;
            });

            // Send ALL active overrides
            const overrides = Object.entries(currentFaderValues).map(([a, v]) => ({
                address: parseInt(a),
                value: v
            }));

            if (ws && ws.readyState === 1) {
                ws.send(JSON.stringify({
                    type: 'laser_override',
                    overrides: overrides
                }));
            }
        }

        async function saveGlobalPreset() {
            await performPresetSave();
        }

        async function performPresetSave() {
            const devName = document.getElementById('test-dev-select').value;
            let allDevices = stageConfig.devices || {};
            const dev = allDevices[devName];
            if (!dev || !currentProfile || !currentProfile.channels) {
                alert("Please select a valid device and profile first.");
                return;
            }

            let presetPayload = {};
            let hasData = false;
            Object.entries(currentProfile.channels).forEach(([role, val]) => {
                const offset = typeof val === 'object' ? val.offset : val;
                const absAddr = dev.address + dev.offset + offset;

                // ONLY include if specifically active for save
                if (saveActiveChannels[absAddr] && currentFaderValues[absAddr] !== undefined) {
                    presetPayload[role] = currentFaderValues[absAddr];
                    hasData = true;
                }
            });

            if (!hasData) {
                alert("No active fader data found. Move some faders or check the 'Include' boxes first!");
                return;
            }

            const presetName = prompt("Enter a name for this Preset (e.g., 'Red Dot High'):");
            if (!presetName) return;

            let vibe = prompt("Assign a vibe (chill, mid, high, sub, tearout, machine_gun, wonky):", "mid");
            if (!vibe) return;
            vibe = vibe.toLowerCase().trim();

            // Persist to presets.json
            let existingPresets = {};
            try {
                const res = await fetch(`${API_BASE}/presets.json?t=${Date.now()}`, { cache: 'no-store' });
                if (res.ok) existingPresets = await res.json();
            } catch (e) {
                console.log("No existing presets.json found. Creating new one.");
            }

            existingPresets[presetName] = {
                vibe: vibe,
                target_category: dev.category || 'laser',
                profile: dev.type,
                channels: presetPayload
            };

            try {
                const saveRes = await fetch(`${API_BASE}/presets.json`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(existingPresets, null, 4)
                });

                if (saveRes.ok) {
                    alert(`\u2705 Saved Preset: '${presetName}' (${vibe}) successfully!`);
                    renderPresetsManager(true);
                } else {
                    alert("\u274c Failed to save preset. Check server logs.");
                }
            } catch (e) {
                console.error(e);
                alert("\u274c Error saving preset.");
            }
        }

        // --- PRESET MANAGER ---
        let allPresetsData = {};

        async function renderPresetsManager(forceRefresh = false) {
            if (forceRefresh || Object.keys(allPresetsData).length === 0) {
                try {
                    const res = await fetch(`${API_BASE}/presets.json?t=${Date.now()}`, {
                        cache: 'no-store'
                    });
                    if (res.ok) {
                        allPresetsData = await res.json();
                    } else {
                        allPresetsData = {};
                    }
                } catch (e) {
                    console.error("Presets load error", e);
                    allPresetsData = {};
                }
            }

            const container = document.getElementById('presets-list');
            if (!container) return;
            container.innerHTML = '';

            let html = '';
            Object.entries(allPresetsData).forEach(([pName, pData]) => {
                const escapedName = pName.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
                html += `
                    <div class="device-row" style="display: grid; grid-template-columns: 2fr 1fr 1fr 1fr 120px 50px; align-items: center;">
                        <input type="text" value="${pName.replace(/"/g, '&quot;')}" readonly style="background:transparent; border:none; outline:none; font-weight:bold; color:var(--text);">
                        <div style="color:var(--text-dim); text-overflow: ellipsis; overflow: hidden; white-space: nowrap;" title="${pData.profile || 'Any'}">${pData.profile || 'Any'}</div>
                        <div style="color:var(--text-dim);">${pData.target_category || 'laser'}</div>
                        <select onchange="updatePresetVibe('${escapedName}', this.value)" style="background:#1a1a24; border-color:#333; color:#ccc; width:100%;">
                            <option value="chill" ${pData.vibe === 'chill' ? 'selected' : ''}>chill</option>
                            <option value="mid" ${pData.vibe === 'mid' ? 'selected' : ''}>mid</option>
                            <option value="high" ${pData.vibe === 'high' ? 'selected' : ''}>high</option>
                            <option value="sub" ${pData.vibe === 'sub' ? 'selected' : ''}>sub</option>
                            <option value="tearout" ${pData.vibe === 'tearout' ? 'selected' : ''}>tearout</option>
                            <option value="machine_gun" ${pData.vibe === 'machine_gun' ? 'selected' : ''}>machine_gun</option>
                            <option value="wonky" ${pData.vibe === 'wonky' ? 'selected' : ''}>wonky</option>
                        </select>
                        <button class="btn accent" style="padding:4px 10px; font-size:12px; height:28px;" onclick="playPreset('${escapedName}')">\u25b6 Play</button>
                        <button class="kv-remove" onclick="deletePreset('${escapedName}')">\u2716</button>
                    </div>
                `;
            });

            if (html === '') {
                container.innerHTML = '<div style="text-align:center; padding:20px; color:var(--text-dim);">No presets saved yet. Go to Live Test to create some!</div>';
            } else {
                container.innerHTML = html;
            }
        }

        async function updatePresetVibe(pName, newVibe) {
            if (allPresetsData[pName]) {
                console.log(`Updating ${pName} vibe to ${newVibe}`);
                allPresetsData[pName].vibe = newVibe;
                renderPresetsManager(); // Re-render to update grouping if needed
                await savePresetsFile(); // Persist immediately
            }
        }

        function playPreset(pName) {
            if (ws && ws.readyState === 1) {
                ws.send(JSON.stringify({ type: 'trigger_scene', scene: 'PRESET:' + pName }));
                alert("Triggered " + pName + ". (Will play on associated fixtures until next rhythm change)");
            } else {
                alert("WebSocket not connected!");
            }
        }

        async function deletePreset(pName) {
            if (confirm("Are you sure you want to delete the preset '" + pName + "'?")) {
                console.log("Deleting preset:", pName);
                delete allPresetsData[pName];

                // Immediately update UI for responsiveness
                renderPresetsManager(false);

                // Then persist to server
                await savePresetsFile();
            }
        }

        async function savePresetsFile() {
            try {
                const saveRes = await fetch(`${API_BASE}/presets.json`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(allPresetsData, null, 4)
                });

                if (saveRes.ok) {
                    alert('‚úÖ Presets saved successfully!');
                } else {
                    alert("‚ùå Failed to save presets. Check server logs.");
                }
            } catch (e) {
                console.error(e);
                alert("‚ùå Error saving presets.");
            }
        }

        window.onload = init;
    </script>
</body>

</html>